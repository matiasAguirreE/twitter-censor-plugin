# review_tweets.py
"""
An interactive command-line tool to manually review and re-classify tweets
in a CSV file.

This script provides a robust way to clean up and verify datasets generated by
AI or other sources, ensuring high-quality data for model training.

Usage
-----
# Start a review session for a given CSV file
python review_tweets.py data/labeled/tweets_generated_all.csv

# Resume a session from a specific tweet ID
python review_tweets.py data/labeled/tweets_generated_all.csv --start-from 1050

How it works
------------
- It iterates through each tweet in the CSV.
- For each tweet, it displays the text and current labels.
- You can input a new label combination (e.g., 'V+H', 'clean'), skip the
  tweet, or quit and save.
- Progress is saved automatically on exit, whether by completing the file,
  using the 'q' command, or pressing Ctrl+C.
"""

from __future__ import annotations

import argparse
import os
import sys
import time
from typing import Any

import pandas as pd

# --- Configuration ---
# Mapeo de códigos de una letra a la información de la etiqueta
LABEL_INFO = {
    "V": {"name": "Violencia", "desc": "Violento"},
    "H": {"name": "Homofobia", "desc": "Homofóbico"},
    "X": {"name": "Xenofobia", "desc": "Xenofóbico"},
}
# Nombres de las columnas de etiquetas en el CSV
LABEL_COLUMNS = [info["name"] for info in LABEL_INFO.values()] + ["Incensurable"]

# Generate all valid label combinations for display and validation
ALL_LABEL_COMBOS_DISPLAY = []
ALL_LABEL_COMBOS_VALIDATION = set()

# Single labels
for code in sorted(LABEL_INFO.keys()):
    ALL_LABEL_COMBOS_DISPLAY.append(code)
    ALL_LABEL_COMBOS_VALIDATION.add(code.lower())

# Two-label combinations
codes_list = sorted(LABEL_INFO.keys())
for i in range(len(codes_list)):
    for j in range(i + 1, len(codes_list)):
        combo_sorted = sorted([codes_list[i], codes_list[j]])
        combo_str = "+".join(combo_sorted)
        ALL_LABEL_COMBOS_DISPLAY.append(combo_str)
        ALL_LABEL_COMBOS_VALIDATION.add(combo_str.lower())
        # Also add permutations for validation (e.g., H+V if V+H is canonical)
        ALL_LABEL_COMBOS_VALIDATION.add("+".join(reversed(combo_sorted)).lower())

# Three-label combination (assuming V, H, X are the only fundamental ones)
if len(LABEL_INFO.keys()) == 3:
    combo_sorted = sorted(LABEL_INFO.keys())
    combo_str = "+".join(combo_sorted)
    ALL_LABEL_COMBOS_DISPLAY.append(combo_str)
    ALL_LABEL_COMBOS_VALIDATION.add(combo_str.lower())

# Add clean/none/incensurable
ALL_LABEL_COMBOS_DISPLAY.append("clean")
ALL_LABEL_COMBOS_VALIDATION.update({"clean", "none", "incensurable"})

# Format for display
LABEL_INPUT_DISPLAY_STRING = ", ".join(ALL_LABEL_COMBOS_DISPLAY)

# --- Helper Functions ---

def clear_screen():
    """Clears the console screen."""
    os.system('cls' if os.name == 'nt' else 'clear')

def get_label_string_from_row(row: pd.Series) -> str:
    """Converts the binary flags from a row into a human-readable string."""
    if row["Incensurable"] == 1:
        return "clean"
    
    parts = [code for code, info in LABEL_INFO.items() if row[info["name"]] == 1]
    return "+".join(sorted(parts)) if parts else "none"

def update_row_from_label_string(label_str: str) -> dict[str, int]:
    """Creates a dictionary of new binary flags from a label string."""
    label_str = label_str.lower()
    new_labels = {col: 0 for col in LABEL_COLUMNS}

    if label_str in {"clean", "none", "incensurable"}:
        new_labels["Incensurable"] = 1
        return new_labels

    parts = {part.upper() for part in label_str.replace(" ", "").split("+")}
    for code in parts:
        if code in LABEL_INFO:
            new_labels[LABEL_INFO[code]["name"]] = 1
            
    return new_labels

def save_and_exit(df: pd.DataFrame, filepath: str, reviewed_count: int):
    """Saves the DataFrame to the CSV and exits the script."""
    print(f"\n\nGuardando cambios en {filepath}...")
    try:
        # Filter out rows marked for deletion before saving
        df_to_save = df[df['_to_delete'] == False].drop(columns=['_to_delete'])
        df_to_save.to_csv(filepath, index=False)
        print(f"¡Éxito! Se revisaron {reviewed_count} tweets en esta sesión.")
    except Exception as e:
        print(f"\nError al guardar el archivo: {e}", file=sys.stderr)
    sys.exit(0)

# --- Main Application ---

def main():
    parser = argparse.ArgumentParser(
        description="Herramienta interactiva para revisar y clasificar tweets en un CSV.",
        formatter_class=argparse.RawTextHelpFormatter
    )
    parser.add_argument("filepath", help="Ruta al archivo CSV a revisar.")
    parser.add_argument(
        "--start-from",
        type=int,
        default=0,
        help="ID del tweet desde el cual comenzar la revisión (para reanudar sesiones)."
    )
    args = parser.parse_args()

    try:
        df = pd.read_csv(args.filepath)
    except FileNotFoundError:
        print(f"Error: No se encontró el archivo en '{args.filepath}'", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error al leer el archivo CSV: {e}", file=sys.stderr)
        sys.exit(1)

    # Add a column to mark tweets for deletion
    df['_to_delete'] = False

    total_tweets = len(df)
    reviewed_in_session = 0

    # Main loop wrapped in a try/except to catch Ctrl+C
    try:
        for index, row in df.iterrows():
            # Skip until we reach the desired starting ID
            if row["ID"] < args.start_from:
                continue

            current_labels = get_label_string_from_row(row)
            
            # Inner loop for handling input for the current tweet
            while True:
                clear_screen()
                print(f"--- Revisando Tweet {index + 1} de {total_tweets} (ID: {row['ID']}) ---")
                print("\nTweet:")
                print(f"  {row['Tweet']}")
                print(f"\nEtiquetas actuales: {current_labels}")
                # Display deletion status if marked
                if df.loc[index, '_to_delete']:
                    print("  (MARCADO PARA ELIMINAR)")
                print("-" * 20)
                print("Comandos:")
                print(f"  - Nuevas etiquetas: {LABEL_INPUT_DISPLAY_STRING}")
                print("  - [s]altar tweet")
                print("  - [d]eliminar tweet (alternar)")
                print("  - [q]uit y guardar")
                
                user_input = input("\n> ").strip().lower()

                if user_input == 'q':
                    save_and_exit(df, args.filepath, reviewed_in_session)
                
                elif user_input == 's':
                    break # Skip to the next tweet

                elif user_input == 'd':
                    df.loc[index, '_to_delete'] = not df.loc[index, '_to_delete'] # Toggle delete status
                    print(f"\nTweet {row['ID']} marcado para {'ELIMINAR' if df.loc[index, '_to_delete'] else 'MANTENER'}.")
                    time.sleep(1) # Give user time to read message
                    continue # Stay on the same tweet to allow user to confirm or change mind

                elif user_input in ALL_LABEL_COMBOS_VALIDATION:
                    new_labels = update_row_from_label_string(user_input)
                    for col, value in new_labels.items():
                        df.loc[index, col] = value
                    
                    # If a tweet was marked for deletion, and now it's being re-labeled, unmark it.
                    if df.loc[index, '_to_delete']:
                        df.loc[index, '_to_delete'] = False
                        print(f"\nTweet {row['ID']} desmarcado para eliminación y re-etiquetado.")
                        time.sleep(1)

                    reviewed_in_session += 1
                    break # Valid input, move to next tweet
                
                else:
                    print(f"\nEntrada '{user_input}' no reconocida. Inténtalo de nuevo.")
                    time.sleep(2)

    except KeyboardInterrupt:
        print("\n\nInterrupción detectada (Ctrl+C).")
        save_and_exit(df, args.filepath, reviewed_in_session)
    
    # If the loop completes normally
    print("\n\n¡Has revisado todos los tweets!")
    save_and_exit(df, args.filepath, reviewed_in_session)


if __name__ == "__main__":
    main()